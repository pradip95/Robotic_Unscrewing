// Generated by gencpp from file control_lib/String_cmdResponse.msg
// DO NOT EDIT!


#ifndef CONTROL_LIB_MESSAGE_STRING_CMDRESPONSE_H
#define CONTROL_LIB_MESSAGE_STRING_CMDRESPONSE_H


#include <memory>
#include <string>
#include <vector>

#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>
#include <ros/serialization.h>
#include <ros/types.h>


namespace control_lib {
template <class ContainerAllocator>
struct String_cmdResponse_
{
  typedef String_cmdResponse_<ContainerAllocator> Type;

  String_cmdResponse_()
    : res()
  {
  }
  String_cmdResponse_(const ContainerAllocator& _alloc)
    : res(_alloc)
  {
    (void)_alloc;
  }


  typedef std::basic_string<
    char,
    std::char_traits<char>,
    typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char> >
    _res_type;
  _res_type res;


  typedef boost::shared_ptr< ::control_lib::String_cmdResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::control_lib::String_cmdResponse_<ContainerAllocator> const> ConstPtr;

}; // struct String_cmdResponse_

typedef ::control_lib::String_cmdResponse_<std::allocator<void> > String_cmdResponse;

typedef boost::shared_ptr< ::control_lib::String_cmdResponse> String_cmdResponsePtr;
typedef boost::shared_ptr< ::control_lib::String_cmdResponse const> String_cmdResponseConstPtr;

// constants requiring out of line definition


template <typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s,
                         const ::control_lib::String_cmdResponse_<ContainerAllocator>& v)
{
  ros::message_operations::Printer<
    ::control_lib::String_cmdResponse_<ContainerAllocator> >::stream(s, "", v);
  return s;
}


template <typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::control_lib::String_cmdResponse_<ContainerAllocator1>& lhs,
                const ::control_lib::String_cmdResponse_<ContainerAllocator2>& rhs)
{
  return lhs.res == rhs.res;
}

template <typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::control_lib::String_cmdResponse_<ContainerAllocator1>& lhs,
                const ::control_lib::String_cmdResponse_<ContainerAllocator2>& rhs)
{
  return !(lhs == rhs);
}


} // namespace control_lib

namespace ros {
namespace message_traits {


template <class ContainerAllocator>
struct IsMessage< ::control_lib::String_cmdResponse_<ContainerAllocator> > : TrueType
{
};

template <class ContainerAllocator>
struct IsMessage< ::control_lib::String_cmdResponse_<ContainerAllocator> const> : TrueType
{
};

template <class ContainerAllocator>
struct IsFixedSize< ::control_lib::String_cmdResponse_<ContainerAllocator> > : FalseType
{
};

template <class ContainerAllocator>
struct IsFixedSize< ::control_lib::String_cmdResponse_<ContainerAllocator> const> : FalseType
{
};

template <class ContainerAllocator>
struct HasHeader< ::control_lib::String_cmdResponse_<ContainerAllocator> > : FalseType
{
};

template <class ContainerAllocator>
struct HasHeader< ::control_lib::String_cmdResponse_<ContainerAllocator> const> : FalseType
{
};


template <class ContainerAllocator>
struct MD5Sum< ::control_lib::String_cmdResponse_<ContainerAllocator> >
{
  static const char* value() { return "53af918a2a4a2a182c184142fff49b0c"; }

  static const char* value(const ::control_lib::String_cmdResponse_<ContainerAllocator>&)
  {
    return value();
  }
  static const uint64_t static_value1 = 0x53af918a2a4a2a18ULL;
  static const uint64_t static_value2 = 0x2c184142fff49b0cULL;
};

template <class ContainerAllocator>
struct DataType< ::control_lib::String_cmdResponse_<ContainerAllocator> >
{
  static const char* value() { return "control_lib/String_cmdResponse"; }

  static const char* value(const ::control_lib::String_cmdResponse_<ContainerAllocator>&)
  {
    return value();
  }
};

template <class ContainerAllocator>
struct Definition< ::control_lib::String_cmdResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string res\n"
           "\n";
  }

  static const char* value(const ::control_lib::String_cmdResponse_<ContainerAllocator>&)
  {
    return value();
  }
};

} // namespace message_traits
} // namespace ros

namespace ros {
namespace serialization {

template <class ContainerAllocator>
struct Serializer< ::control_lib::String_cmdResponse_<ContainerAllocator> >
{
  template <typename Stream, typename T>
  inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.res);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER
}; // struct String_cmdResponse_

} // namespace serialization
} // namespace ros

namespace ros {
namespace message_operations {

template <class ContainerAllocator>
struct Printer< ::control_lib::String_cmdResponse_<ContainerAllocator> >
{
  template <typename Stream>
  static void stream(Stream& s,
                     const std::string& indent,
                     const ::control_lib::String_cmdResponse_<ContainerAllocator>& v)
  {
    s << indent << "res: ";
    Printer<std::basic_string<char,
                              std::char_traits<char>,
                              typename std::allocator_traits<ContainerAllocator>::
                                template rebind_alloc<char> > >::stream(s, indent + "  ", v.res);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CONTROL_LIB_MESSAGE_STRING_CMDRESPONSE_H
